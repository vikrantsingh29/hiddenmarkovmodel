# -*- coding: utf-8 -*-
"""HiddenMarkovModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1veA1FdNnC8cBOcJIZBsVdatSAL3BsPsI
"""

print ("hello")

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pickle
import pandas as pd

import matplotlib

# Commented out IPython magic to ensure Python compatibility.
# matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
# %matplotlib inline


df = pd.read_fwf("/content/drive/MyDrive/HMM/data07_01_nrw_10-11.txt")
df.columns = ["time", "icao24", "latlng"]
print(df)

"""# New Section"""

df.icao24.unique()

df.icao24.value_counts()

# df2 = df
# minlat = df2['lat'].min()
# print(minlat)
df2 = pd.concat([df['time'],df['icao24'],df['latlng'].str.split(' ', expand=True)], axis=1)
df2.columns = ["time", "icao24", "lat", "lng"]
df2

df2['lat'] = df2['lat'].astype(float)
df2['lng'] = df2['lng'].astype(float)
d = dict(tuple(df2.groupby("icao24")))
print(len(d))

import pandas as pd
import numpy as np

# Define latitude and longitude ranges
lat_range = np.linspace(50, 52, 4+1)
lng_range = np.linspace(5, 9, 4+1)

# Define function to map point to cell
def map_to_cell(lat, lng):
    lat_idx = np.searchsorted(lat_range, lat) - 1
    lng_idx = np.searchsorted(lng_range, lng) - 1
    return lat_idx * 4 + lng_idx

# Initialize dictionary to store trajectories
trajectories = {}

# Group dataframe by icao24 code
grouped_df = df2.groupby('icao24')

# Loop over each flight
for icao24, flight in grouped_df:
    trajectory = []
    
    # Map each point to a cell
    for _, row in flight.iterrows():
        lat, lng = row['lat'], row['lng']
        cell = map_to_cell(lat, lng)
        trajectory.append(cell)
    
    # Add trajectory to dictionary
    trajectories[icao24] = trajectory

print(trajectories.values())

# Define sequence length
sequence_length = 4

# Initialize list to store sequences
sequences = []

# Loop over each trajectory
for trajectory in trajectories.values():
    # Loop over each sequence
    for i in range(len(trajectory) - sequence_length + 1):
        # Extract sequence
        sequence = trajectory[i:i+sequence_length]
        sequences.append(sequence)
        
# Output sequences
print(sequences)

# Count the occurrences of each unique sequence
sequence_counts = {}
for seq in sequences:
    if tuple(seq) not in sequence_counts:
        sequence_counts[tuple(seq)] = 0
    sequence_counts[tuple(seq)] += 1

# Create a transition matrix
n_sequences = len(sequence_counts)
sequence_indices = {seq: i for i, seq in enumerate(sequence_counts)}
transition_matrix = np.zeros((n_sequences, n_sequences))

# Loop over each sequence
for i in range(len(sequences) - 1):
    current_seq = tuple(sequences[i])
    next_seq = tuple(sequences[i+1])
    adjacent_count = sum(1 for j in range(len(sequences) - 1) if tuple(sequences[j]) == current_seq and tuple(sequences[j+1]) == next_seq)
    current_seq_count = sequence_counts[current_seq]
    current_seq_index = sequence_indices[current_seq]
    next_seq_index = sequence_indices[next_seq]    
    # Increment the transition count
    transition_matrix[current_seq_index, next_seq_index] = adjacent_count / current_seq_count

# # Normalize the transition matrix
# row_sums = transition_matrix.sum(axis=1, keepdims=True)
# transition_matrix = transition_matrix / row_sums

# Output number of unique sequences and transition matrix
print("Number of unique sequences:", n_sequences)
print("Transition matrix:")
print(transition_matrix)


import matplotlib.pyplot as plt

# Create an example array
arr = transition_matrix

# Visualize the array using imshow
plt.imshow(arr, cmap='viridis')
plt.colorbar()
plt.show()

# Count the occurrences of each unique sequence
sequence_counts = {}
for seq in sequences:
    if tuple(seq) not in sequence_counts:
        sequence_counts[tuple(seq)] = 0
    sequence_counts[tuple(seq)] += 1


# sequence_indices = {seq: i for i, seq in enumerate(sequence_counts)}
# # Define the number of grid cells
# n_cells = 16

# # Create an emission matrix
# n_sequences = len(sequence_counts)
# emission_matrix = np.zeros((n_sequences, n_cells))

observations = np.arange(1, 17)

# # Loop over each unique sequence
# for i, seq in enumerate(sequence_counts.keys()):
#     for obs in range(1, n_cells+1):
#         # Compute the emission probability
#         num_obs = sum(1 for j in range(len(sequences)) if tuple(sequences[j]) == seq and observations[j] == obs)
#         emission_matrix[i, obs-1] = num_obs / sequence_counts[seq]

# # Output number of unique sequences and emission matrix
# print("Number of unique sequences:", n_sequences)
# print("Emission matrix:")
# print(emission_matrix)

# Define the number of grid cells
n_cells = 16

# Create an emission matrix
n_sequences = len(sequence_counts)
emission_matrix = np.zeros((n_sequences, n_cells))

# Loop over each unique sequence
for i, seq in enumerate(sequence_counts.keys()):
    for obs in range(1, n_cells+1):
        # Compute the emission probability
        num_obs = sum(1 for j in range(len(observations)) if tuple(sequences[j]) == seq and observations[j] == obs)
        emission_matrix[i, obs-1] = num_obs / sequence_counts[seq]

# Output number of unique sequences and emission matrix
print("Number of unique sequences:", n_sequences)
print("Emission matrix:")
# np.set_printoptions(threshold=np.inf)
print(emission_matrix)


import matplotlib.pyplot as plt

# Create an example array
arr = emission_matrix

# Visualize the array using imshow
plt.imshow(arr, cmap='viridis')
plt.colorbar()
plt.show()

print(sequence_counts.keys())



# Count the number of times each state appears as the first state in the sequences
# start_counts = {}
# for seq in sequences:
#     start_seq = tuple(seq[0])
#     print(start_seq)
#     if state not in start_counts:
#         start_counts[state] = 0
#     start_counts[state] += 1

# # Normalize the counts to obtain probabilities
# start_probabilities = {}
# total_counts = sum(start_counts.values())
# for state, count in start_counts.items():
#     start_probabilities[state] = count / total_counts

# print("Start probabilities:")
# print(sequence_counts.keys())
# print(sequences)



starting_sequences = []
for traj in trajectories.values():
    starting_sequence = tuple(traj[:4])
    starting_sequences.append(starting_sequence)

# print(starting_sequences)


sequence_counts1 = {}
for seq in starting_sequences:
    if seq in sequence_counts1:
        sequence_counts1[seq] += 1
    else:
        sequence_counts1[seq] = 1

start_probs = {}
for seq in sequence_counts1:
    start_probs[seq] = sequence_counts1[seq] / len(starting_sequences)

# start_probs_array = np.array(list(start_probs.values()))
print(start_probs.values())

num_sequences = len(sequences)
unique_sequences = list(sequence_counts.keys())
num_unique_sequences = len(unique_sequences)
startprobs = np.zeros(num_unique_sequences)

for i, seq in enumerate(unique_sequences):
    count = sequence_counts[seq]
    startprobs[i] = count / num_sequences

print (startprobs)

!pip install hmmlearn

from hmmlearn.hmm import GaussianHMM

n_components = 183
covariance_type = "diag"

hmm_model = GaussianHMM(n_components=n_components, covariance_type=covariance_type)

start_probs_array = np.array(list(start_probs.values()))
hmm_model.startprob_ = start_probs
hmm_model.transmat_ = transition_matrix
hmm_model.emissionprob_ = emission_matrix

# Define the observation sequence
observations = np.arange(1, 17)

# Initialize the Viterbi variables
delta = np.zeros((len(observations), len(startprobs)))
phi = np.zeros((len(observations), len(startprobs)))


print(phi.shape)

# Compute delta and phi for the first observation
for i in range(len(startprobs)):
    delta[0, i] = startprobs[i] * emission_matrix[i, observations[0]-1]
    phi[0, i] = 0

# Compute delta and phi for the rest of the observations
for t in range(1, len(observations)):
    for j in range(len(startprobs)):
        max_delta = 0
        max_phi = 0
        for i in range(len(startprobs)):
            temp_delta = delta[t-1, i] * transition_matrix[i, j] * emission_matrix[j, observations[t]-1]
            if temp_delta > max_delta:
                max_delta = temp_delta
                max_phi = i
        delta[t, j] = max_delta
        phi[t, j] = max_phi

# Find the maximum probability and the corresponding state sequence
max_prob = 0
state_seq = np.zeros(len(observations), dtype=int)
for i in range(len(startprobs)):
    if delta[-1, i] > max_prob:
        max_prob = delta[-1, i]
        state_seq[-1] = i
for t in range(len(observations)-2, -1, -1):
    state_seq[t] = phi[t+1, state_seq[t+1]]

# # Print the most likely state sequence and its probability
# print("Most likely state sequence:", state_seq)
# print("Probability of the most likely state sequence:", max_prob)

# from collections import Counter
# import numpy as np

# # Convert sub-lists to tuples within the sequences list
# sequences = [tuple(seq) for seq in sequences]

# # Count the occurrences of each sequence
# sequence_counts = Counter(sequences)

# # Get the unique sequences and their indices
# unique_sequences = list(sequence_counts.keys())
# n_sequences = len(unique_sequences)
# sequence_indices = {seq: i for i, seq in enumerate(unique_sequences)}

# # Create a transition matrix
# transition_matrix = np.zeros((n_sequences, n_sequences))

# # Loop over each sequence
# for i in range(len(sequences) - 1):
#     current_seq = sequences[i]
#     next_seq = sequences[i+1]
#     adjacent_count = sum(1 for j in range(len(sequences) - 1) if sequences[j] == current_seq and sequences[j+1] == next_seq)
#     current_seq_count = sequence_counts[current_seq]
#     current_seq_index = sequence_indices[current_seq]
#     next_seq_index = sequence_indices[next_seq]
    
#     # Increment the transition count
#     transition_matrix[current_seq_index, next_seq_index] += adjacent_count / current_seq_count

# # Output number of unique sequences and transition matrix
# print("Number of unique sequences:", n_sequences)
# print("Transition matrix:")
# print(transition_matrix)

# # import json
# # from sklearn.cluster import KMeans

# # # A list to store all the hidden states
# # all_hidden_states = []

# # # Group the DataFrame by the 'icao24' column
# # grouped_df = df2.groupby(by='icao24')

# # # Define the length of the sub-trajectories
# # sub_trajectory_length = 4

# # # A list to store all the hidden states
# # all_hidden_states = []


# # # A dictionary to store the mapping between sub-trajectories and their assigned hidden states
# # hidden_state_mapping = {}
# # hidden_state_counter = 0

# # # Loop through the groups
# # for icao24, group in grouped_df:
# #     # Extract the points from the group
# #     points = group[['lat', 'lng']].values.tolist()

# #      # Divide the full trajectory into sub-trajectories of 6 points each
# #     sub_trajectories = [points[i:i + sub_trajectory_length] for i in range(0, len(points), sub_trajectory_length)]
# #     # Define the hidden states for this group (i.e. for this icao24 value)
# #     hidden_states = []
    
# #     # Loop through the sub-trajectories
# #     for sub_trajectory in sub_trajectories:
# #         # Check if the sub-trajectory has been seen before
# #         if sub_trajectory not in hidden_state_mapping:
# #             # If not, assign a new hidden state to it
# #             hidden_state_mapping[sub_trajectory] = hidden_state_counter
# #             hidden_state_counter += 1
        
# #         # Add the hidden state for this sub-trajectory to the list of hidden states for this group
# #         hidden_states.append(hidden_state_mapping[sub_trajectory])
        
# #     # Append the hidden states for this group to the list of all hidden states
# #     all_hidden_states.append(hidden_states)

# # # Flatten the list of all hidden states
# # all_hidden_states = [hidden_state for sublist in all_hidden_states for hidden_state in sublist]




# # # Initialize the transition matrix with zeros
# # transition_matrix = np.zeros((n_hidden_states, n_hidden_states))

# # # Loop through the hidden states
# # for i in range(len(all_hidden_states)-1):
# #     current_state = all_hidden_states[i]
# #     next_state = all_hidden_states[i+1]
# #     transition_matrix[current_state][next_state] += 1

# # # Normalize the matrix
# # transition_matrix = transition_matrix / transition_matrix.sum(axis=1, keepdims=True)

# # print(transition_matrix)

# import pandas as pd

# def divide_into_sub_trajectories(df2):
#     # Dictionary to store the sub-trajectories for each trajectory
#     sub_trajectories = {}

#     # Loop over each unique icao24 code
#     for icao24, data in df2.groupby('icao24'):
#         # Divide the trajectory into sub-trajectories of 4 data points
#         sub_trajectories[icao24] = [data.iloc[i:i+4, 2:4] for i in range(0, data.shape[0], 4)]

#     return sub_trajectories


# # Divide each trajectory into sub-trajectories
# sub_trajectories = divide_into_sub_trajectories(df2)


# # Create a list to store the hidden states
# hidden_states = []

# # Loop over each icao24 code

# for icao24, traj in sub_trajectories.items():
#     # Loop over each sub-trajectory
#     for sub_traj in traj:
#         # Convert the sub-trajectory to a list
#         sub_traj_list = sub_traj.values.tolist()


#         # Append the sub-trajectory to the list of hidden states if it is not already in the list
#         if sub_traj_list not in hidden_states:
#             hidden_states.append(sub_traj_list)


# # Number of sub-trajectories
# num_sub_trajectories = len(hidden_states)
# print(f'Number of sub-trajectories: {num_sub_trajectories}')


# # Convert the list of hidden states to a numpy array
# hidden_states = np.array(hidden_states)

# # Number of unique hidden states
# num_hidden_states = hidden_states.shape[0]
# print(f'Number of unique hidden states: {num_hidden_states}')

# import pandas as pd
# import numpy as np


# # Load your dataset
# df = df2

# # Define a function to create sub-trajectories from a given trajectory
# def create_sub_trajectories(trajectory):
#     num_points = len(trajectory)
#     num_sub_traj = num_points - 1
#     sub_traj_len = num_points // num_sub_traj
#     sub_trajectories = []
#     for i in range(num_sub_traj):
#         sub_traj = trajectory[i * sub_traj_len : (i+1) * sub_traj_len]
#         sub_trajectories.append(sub_traj)
#     return sub_trajectories

# # Define a set to store the unique hidden states
# hidden_states = set()

# # Define a dictionary to store the counts of each state and transition
# state_counts = {}

# # Iterate over each unique icao24 code in the dataset
# for icao24 in df['icao24'].unique():
#     # Get the trajectory for the current icao24 code
#     traj = df[df['icao24'] == icao24][['lat', 'lng']].values
#     # Create sub-trajectories
#     sub_trajectories = create_sub_trajectories(traj)
#     # Iterate over each sub-trajectory
#     for i in range(len(sub_trajectories)):
#         # Get the current sub-trajectory
#         sub_traj = sub_trajectories[i]
#         # Convert the sub-trajectory to a tuple
#         sub_traj_tuple = tuple(map(tuple, sub_traj))
#         # Add the sub-trajectory to the set of unique hidden states
#         hidden_states.add(sub_traj_tuple)
#         # Get the current state count
#         state_counts[sub_traj_tuple] = state_counts.get(sub_traj_tuple, 0) + 1
#         # If this is not the first sub-trajectory, update the transition count
#         if i > 0:
#             prev_sub_traj = sub_trajectories[i-1]
#             prev_sub_traj_tuple = tuple(map(tuple, prev_sub_traj))
#             state_counts[(prev_sub_traj_tuple, sub_traj_tuple)] = state_counts.get((prev_sub_traj_tuple, sub_traj_tuple), 0) + 1

# # Calculate the transition probabilities
# A = np.zeros((len(hidden_states), len(hidden_states)))
# for i, state in enumerate(hidden_states):
#     num_state = state_counts[state]
#     for j, next_state in enumerate(hidden_states):
#         num_next_state = state_counts.get((state, next_state), 0)
#         A[i,j] = num_next_state / num_state


# # Print the transition matrix shape
# # print(A.shape)


# # Print the transition matrix
# # print(transition_matrix)
# # first_10_rows = A[110:130]

# # # for row in (first_10_rows):
# # #       print(row)

# # import seaborn as sns
# # import numpy as np
# # import matplotlib.pyplot as plt

# # # compute the correlation matrix
# # corr_matrix = np.corrcoef(first_10_rows)

# # fig, ax = plt.subplots(figsize=(18, 16))

# # # create a heatmap with colored cells
# # sns.heatmap(corr_matrix, cmap='coolwarm', annot=True, ax=ax)

# import matplotlib.pyplot as plt
# import numpy as np



# # Create a sample matrix
# mat = A

# # Get the unique values and their frequencies
# unique_values, frequencies = np.unique(mat, return_counts=True)

# # Print the frequencies
# print("Value Frequencies:")
# for value, freq in zip(unique_values, frequencies):
#     print(f"{value}: {freq}")

# # # Plot a scatterplot of the matrix values
# # x, y = np.meshgrid(np.arange(mat.shape[0]), np.arange(mat.shape[1]))
# # plt.scatter(x, y, s=mat.flatten()*100, c=mat.flatten())
# # plt.show()

# import numpy as np

# # Define the emission matrix size
# num_cells = 16

# # Define a dictionary to store the counts of each state and observation
# obs_counts = {}

# # Iterate over each hidden state and calculate the emission probabilities
# B = np.zeros((len(hidden_states), num_cells))
# for i, state in enumerate(hidden_states):
#     num_state = state_counts[state]
#     for j in range(num_cells):
#         # Count the number of times the observation occurs in the hidden state
#         obs_count = 0
#         for point in state:
#             if point[0] >= j/num_cells and point[0] < (j+1)/num_cells and point[1] >= j/num_cells and point[1] < (j+1)/num_cells:
#                 obs_count += 1
#         obs_counts[(state, j)] = obs_count
#         B[i,j] = obs_count / num_state

# print(B)

# import pandas as pd
# import numpy as np

# # Load the sample data
# df = df2

# # Define the latitude and longitude ranges
# lat_range = (50, 52)
# lng_range = (5, 9)

# # Define the number of cells in the grid
# num_cells = (4, 4)

# # Define a function to create sub-trajectories from a given trajectory
# # def create_sub_trajectories(trajectory, num_cells):
# #     num_points = len(trajectory)
# #     cell_size = (num_points // num_cells[0], num_points // num_cells[1])
# #     sub_trajectories = []
# #     for i in range(num_cells[0]):
# #         for j in range(num_cells[1]):
# #             sub_traj = trajectory[i * cell_size[0] : (i+1) * cell_size[0], j * cell_size[1] : (j+1) * cell_size[1]]
# #             sub_trajectories.append(sub_traj)
# #     return sub_trajectories




# # Get the unique icao24 codes from the dataset
# icao24_codes = df['icao24'].unique()

# # Define a set to store the unique hidden states
# hidden_states = set()

# # Define a dictionary to store the counts of each state and transition
# state_counts = {}

# # Iterate over each icao24 code and create sub-trajectories
# for icao24 in icao24_codes:
#     # Get the trajectory for the current icao24 code
#     traj = df[df['icao24'] == icao24][['lat', 'lng']].values
#     # Create sub-trajectories
#     sub_trajectories = create_sub_trajectories(traj, num_cells)
#     # Iterate over each sub-trajectory
#     # for sub_traj in sub_trajectories:
#     #     # Convert the sub-trajectory to a tuple
#     #     sub_traj_tuple = tuple(map(tuple, sub_traj))
#     #     # Add the sub-trajectory to the set of unique hidden states
#     #     hidden_states.add(sub_traj_tuple)
#     #     # Get the current state count
#     #     state_counts[sub_traj_tuple] = state_counts.get(sub_traj_tuple, 0) + 1
#     #     # If this is not the first sub-trajectory, update the transition count
#     #     if len(sub_trajectories) > 1:
#     #         prev_sub_traj = sub_trajectories[sub_trajectories.index(sub_traj)-1]
#     #         prev_sub_traj_tuple = tuple(map(tuple, prev_sub_traj))
#     #         state_counts[(prev_sub_traj_tuple, sub_traj_tuple)] = state_counts.get((prev_sub_traj_tuple, sub_traj_tuple), 0) + 1

# print(len(sub_trajectories) , "subtrajectories")


# # # Calculate the transition probabilities
# # A = np.zeros((len(hidden_states), len(hidden_states)))
# # for i, state in enumerate(hidden_states):
# #     num_state = state_counts[state]
# #     for j, next_state in enumerate(hidden_states):
# #         num_next_state = state_counts.get((state, next_state), 0)
# #         A[i,j] = num_next_state / num_state

# # # Define a function to create a cell index lookup table
# # def create_lookup_table(num_cells):
# #     lookup_table = {}
# #     cell_idx = 0
# #     for i in range(num_cells[0]):
# #         for j in range(num_cells[1]):
# #             lookup_table[(i, j)] = cell_idx
# #             cell_idx += 1
# #     return lookup_table

# # # Define a list to store the observed states
# # observed_states = [(i, j) for i in range(num_cells) for j in range(num_cells)]

# # # Define a dictionary to store the counts of each observation
# # obs_counts = {}

# # # Iterate over each hidden state and observed state
# # for hidden_state in hidden_states:
# #     for obs_state in observed_states:
# #         # Count the number of times the observed state was observed in the hidden state
# #         obs_count = sum(1 for point in hidden_state if in_range(point, obs_state))
# #         # Add the count to the dictionary
# #         obs_counts[(hidden_state, obs_state)] = obs_count

# # # Calculate the emission probabilities
# # B = np.zeros((len(hidden_states), len(observed_states)))
# # for i, hidden_state in enumerate(hidden_states):
# #     num_hidden_state = state_counts[hidden_state]
# #     for j, obs_state in enumerate(observed_states):
# #         num_obs_given_hidden = obs_counts.get((hidden_state, obs_state), 0)
# #         B[i,j] = num_obs_given_hidden / num_hidden_state

import pandas as pd

# Read in the data
data = df2

# Group the data by icao24 code
groups = data.groupby("icao24")

# Loop through each group and calculate the number of points and sub-trajectories
for name, group in groups:
    # Calculate the number of points in the trajectory
    num_points = group.shape[0]
    
    # Calculate the number of sub-trajectories
    num_subtraj = num_points - 1
    
    # Print out the results for this trajectory
    print("icao24 code:", name)
    print("Number of points:", num_points)
    print("Number of sub-trajectories:", num_subtraj)

# # loop through each unique icao24 code
# hidden_states = []

# for icao in data['icao24'].unique():
#     # get the subset of data for a particular icao24 code
#     sub_data = data.loc[data['icao24'] == icao, ['lat', 'lng']]
#     # get the number of points in the trajectory
#     num_points = sub_data.shape[0]
#     # calculate the number of subtrajectories
#     num_subtraj = num_points - 1
#     # initialize the hidden state list for this trajectory
#     # loop through each subtrajectory
#     for i in range(num_subtraj):
#         # get the start and end indices of the subtrajectory
#         start_index = i
#         end_index = i + 4
#         # extract the subtrajectory from the data
#         subtraj = sub_data.iloc[start_index:end_index, :]
#         # add the subtrajectory to the list of hidden states
#         hidden_states.append(subtraj)

# import numpy as np

# # Define the number of points in each trajectory
# c = 20

# # Define the lat-lng grid
# lat_range = np.arange(50, 52.01, 0.02)
# lng_range = np.arange(5, 9.01, 0.02)



# # Define the size of the grid cells
# cell_size = 0.02

# # Define the number of hidden states
# num_states = len(lat_range) * len(lng_range)

# # # Initialize an empty list to store the hidden states for each trajectory
# # hidden_states = []

# # # Loop through each trajectory in the dataframe
# # for icao in df2['icao24'].unique():

# #     # Extract the trajectory for the current icao code
# #     trajectories = df2[df2['icao24'] == icao][['lat', 'lng']].values

# #     # Calculate the number of points and sub-trajectories for the current trajectory
# #     num_points = len(trajectories)
# #     num_subtraj = num_points - 1

# #     # Initialize an empty array to store the hidden states for the current trajectory
# #     traj_states = np.zeros(num_subtraj, dtype=int)

# #     for i in range(num_subtraj):
# #         start_idx = i * c
# #         end_idx = start_idx + c
# #         sub_traj = trajectories[start_idx:end_idx]
# #         lat_idx = np.floor((sub_traj[:,0] - lat_range[0])/cell_size)
# #         lng_idx = np.floor((sub_traj[:,1] - lng_range[0])/cell_size)
# #         hidden_state = np.ravel_multi_index((lat_idx, lng_idx), (len(lat_range), len(lng_range)))
# #         traj_states[i] = hidden_state

# #     # Append the hidden states for the current trajectory to the list of hidden states
# #     hidden_states.append(traj_states)

# # print(hidden_states)



# # Initialize the transition matrix with zeros
# n_hidden_states = len(hidden_states)
# transition_matrix = np.zeros((n_hidden_states, n_hidden_states))

# # Loop through the hidden states
# for i in range(len(hidden_states)-1):
#     current_state = hidden_states[i]
#     next_state = hidden_states[i+1]
#     transition_matrix[current_state][next_state] += 1

# # Normalize the matrix
# transition_matrix = transition_matrix / transition_matrix.sum(axis=1, keepdims=True)

# print(transition_matrix)

plt.scatter(x=d['484428']['lat'], y=d['484428']['lng'])

plt.scatter(x=d['3c56f7']['lat'], y=d['3c56f7']['lng'])
# plt.show()

!pip install geemap

!pip install geopandas

from shapely.geometry import Point
import geopandas as gpd
from geopandas import GeoDataFrame

crs ={'init':'epsg:4326'}
geometry = [Point(xy) for xy in zip(df2['lng'], df2['lat'])]
gdf = GeoDataFrame(df2, geometry=geometry)

#this is a simple map that goes with geopandas
world = gpd.read_file('/content/drive/MyDrive/HMM/plz-5stellig.shp')
gdf.plot(ax=world.plot(figsize=(20, 12)), marker='o', color='red', markersize=5);

max_lat = df2['lat'].max()
min_lat = df2['lat'].min()
max_lng = df2['lng'].max()
min_lng = df2['lng'].min()
print(max_lat , max_lng , min_lat,min_lng)

x1, y1, x2, y2 = 50, 5, 52, 9

grid = [[(x, y) for x in range(x1, x2+1)] for y in range(y1, y2+1)]
print(grid)

x1, y1 = 50, 5
x2, y2 = 52, 9

# Create a 4x4 grid of cells
grid = np.zeros((4, 4))

# Plot the grid
fig, ax = plt.subplots()
ax.imshow(grid, cmap='gray', extent=[x1,x2,y1,y2])
ax.grid(True)
plt.show()



import matplotlib.pyplot as plt
import numpy as np
from matplotlib.ticker import FuncFormatter

def y_fmt(y, pos):
    return int(y)

# Define starting and ending coordinates
x1, y1 = 50, 5
x2, y2 = 52, 9

# Create a 4x4 grid of cells
grid = np.zeros((4, 4))

# Plot the grid
fig, ax = plt.subplots(figsize=(8, 6))
ax.imshow(grid, cmap='gray', interpolation='nearest', extent=[x1, x2, y1, y2])
ax.xaxis.set_ticks(np.arange(x1, x2, 0.5))
ax.yaxis.set_ticks(np.arange(y1, y2, 1))
ax.yaxis.set_major_formatter(FuncFormatter(y_fmt))
ax.grid(True)

ax.scatter(d['3c56f7']['lat'],d['3c56f7']['lng'], color='red', marker='o', s=5)
plt.show()

!pip install hmmlearn

# # Define the number of hidden states
# n_states = 3
# n_cells = 16

# # Define the number of transitions between the hidden states
# transitions = np.zeros((n_states, n_cells))

# # Count the number of transitions between the hidden states for 1600 trajectories
# for trajectory in trajectories:
#     for i in range(len(trajectory) - 1):
#         current_state = trajectory[i][0]
#         next_state = trajectory[i + 1][0]
#         transitions[current_state - 1][next_state - 1] += 1

# # Divide the number of transitions by the number of occurrences of each state
# transitions /= transitions.sum(axis=1, keepdims=True)

# import numpy as np
# from hmmlearn import hmm

# # Set the number of hidden states and dimensions
# n_states = 3
# n_dim = 18

# # Set the initial observation probabilities
# start_prob = np.array([0.6, 0.3, 0.1])

# # Set the transition probabilities between states
# trans_prob = transition_matrix

# # Set the means of the observation Gaussians for each state
# means = np.array([[0.0] * n_dim,
#                   [3.0] * n_dim,
#                   [6.0] * n_dim])

# # Set the covariances of the observation Gaussians for each state to the identity matrix
# covars = np.array([np.eye(n_dim)] * n_states)

# # Create the HMM model
# model = hmm.GaussianHMM(n_components=n_states, covariance_type='full')
# model.startprob_ = start_prob
# model.transmat_ = trans_prob
# model.means_ = means
# model.covars_ = covars

# # Fit the model to the data
# X = np.array([[0.1, 0.2, ..., 0.18], [3.1, 4.9, ..., 3.18], ...])
# model.fit(X)

# # Use the model to predict the hidden states for a new set of observations
# X_new = np.array([[0.1, 0.2, ..., 0.18], [3.1, 4.9, ..., 3.18], ...])
# hidden_states = model.predict(X_new)
# print(hidden_states)

